// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.15.8
// source: internal/hecklerpb/hecklerpb.proto

package hecklerpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Heckler_HecklerStatus_FullMethodName    = "/hecklerpb.Heckler/HecklerStatus"
	Heckler_HecklerNoopRange_FullMethodName = "/hecklerpb.Heckler/HecklerNoopRange"
	Heckler_HecklerApply_FullMethodName     = "/hecklerpb.Heckler/HecklerApply"
	Heckler_HecklerLock_FullMethodName      = "/hecklerpb.Heckler/HecklerLock"
	Heckler_HecklerUnlock_FullMethodName    = "/hecklerpb.Heckler/HecklerUnlock"
)

// HecklerClient is the client API for Heckler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HecklerClient interface {
	HecklerStatus(ctx context.Context, in *HecklerStatusRequest, opts ...grpc.CallOption) (*HecklerStatusReport, error)
	HecklerNoopRange(ctx context.Context, in *HecklerNoopRangeRequest, opts ...grpc.CallOption) (*HecklerNoopRangeReport, error)
	HecklerApply(ctx context.Context, in *HecklerApplyRequest, opts ...grpc.CallOption) (*HecklerApplyReport, error)
	HecklerLock(ctx context.Context, in *HecklerLockRequest, opts ...grpc.CallOption) (*HecklerLockReport, error)
	HecklerUnlock(ctx context.Context, in *HecklerUnlockRequest, opts ...grpc.CallOption) (*HecklerUnlockReport, error)
}

type hecklerClient struct {
	cc grpc.ClientConnInterface
}

func NewHecklerClient(cc grpc.ClientConnInterface) HecklerClient {
	return &hecklerClient{cc}
}

func (c *hecklerClient) HecklerStatus(ctx context.Context, in *HecklerStatusRequest, opts ...grpc.CallOption) (*HecklerStatusReport, error) {
	out := new(HecklerStatusReport)
	err := c.cc.Invoke(ctx, Heckler_HecklerStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hecklerClient) HecklerNoopRange(ctx context.Context, in *HecklerNoopRangeRequest, opts ...grpc.CallOption) (*HecklerNoopRangeReport, error) {
	out := new(HecklerNoopRangeReport)
	err := c.cc.Invoke(ctx, Heckler_HecklerNoopRange_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hecklerClient) HecklerApply(ctx context.Context, in *HecklerApplyRequest, opts ...grpc.CallOption) (*HecklerApplyReport, error) {
	out := new(HecklerApplyReport)
	err := c.cc.Invoke(ctx, Heckler_HecklerApply_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hecklerClient) HecklerLock(ctx context.Context, in *HecklerLockRequest, opts ...grpc.CallOption) (*HecklerLockReport, error) {
	out := new(HecklerLockReport)
	err := c.cc.Invoke(ctx, Heckler_HecklerLock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hecklerClient) HecklerUnlock(ctx context.Context, in *HecklerUnlockRequest, opts ...grpc.CallOption) (*HecklerUnlockReport, error) {
	out := new(HecklerUnlockReport)
	err := c.cc.Invoke(ctx, Heckler_HecklerUnlock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HecklerServer is the server API for Heckler service.
// All implementations must embed UnimplementedHecklerServer
// for forward compatibility
type HecklerServer interface {
	HecklerStatus(context.Context, *HecklerStatusRequest) (*HecklerStatusReport, error)
	HecklerNoopRange(context.Context, *HecklerNoopRangeRequest) (*HecklerNoopRangeReport, error)
	HecklerApply(context.Context, *HecklerApplyRequest) (*HecklerApplyReport, error)
	HecklerLock(context.Context, *HecklerLockRequest) (*HecklerLockReport, error)
	HecklerUnlock(context.Context, *HecklerUnlockRequest) (*HecklerUnlockReport, error)
	mustEmbedUnimplementedHecklerServer()
}

// UnimplementedHecklerServer must be embedded to have forward compatible implementations.
type UnimplementedHecklerServer struct {
}

func (UnimplementedHecklerServer) HecklerStatus(context.Context, *HecklerStatusRequest) (*HecklerStatusReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HecklerStatus not implemented")
}
func (UnimplementedHecklerServer) HecklerNoopRange(context.Context, *HecklerNoopRangeRequest) (*HecklerNoopRangeReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HecklerNoopRange not implemented")
}
func (UnimplementedHecklerServer) HecklerApply(context.Context, *HecklerApplyRequest) (*HecklerApplyReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HecklerApply not implemented")
}
func (UnimplementedHecklerServer) HecklerLock(context.Context, *HecklerLockRequest) (*HecklerLockReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HecklerLock not implemented")
}
func (UnimplementedHecklerServer) HecklerUnlock(context.Context, *HecklerUnlockRequest) (*HecklerUnlockReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HecklerUnlock not implemented")
}
func (UnimplementedHecklerServer) mustEmbedUnimplementedHecklerServer() {}

// UnsafeHecklerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HecklerServer will
// result in compilation errors.
type UnsafeHecklerServer interface {
	mustEmbedUnimplementedHecklerServer()
}

func RegisterHecklerServer(s grpc.ServiceRegistrar, srv HecklerServer) {
	s.RegisterService(&Heckler_ServiceDesc, srv)
}

func _Heckler_HecklerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HecklerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HecklerServer).HecklerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Heckler_HecklerStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HecklerServer).HecklerStatus(ctx, req.(*HecklerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Heckler_HecklerNoopRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HecklerNoopRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HecklerServer).HecklerNoopRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Heckler_HecklerNoopRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HecklerServer).HecklerNoopRange(ctx, req.(*HecklerNoopRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Heckler_HecklerApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HecklerApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HecklerServer).HecklerApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Heckler_HecklerApply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HecklerServer).HecklerApply(ctx, req.(*HecklerApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Heckler_HecklerLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HecklerLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HecklerServer).HecklerLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Heckler_HecklerLock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HecklerServer).HecklerLock(ctx, req.(*HecklerLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Heckler_HecklerUnlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HecklerUnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HecklerServer).HecklerUnlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Heckler_HecklerUnlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HecklerServer).HecklerUnlock(ctx, req.(*HecklerUnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Heckler_ServiceDesc is the grpc.ServiceDesc for Heckler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Heckler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hecklerpb.Heckler",
	HandlerType: (*HecklerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HecklerStatus",
			Handler:    _Heckler_HecklerStatus_Handler,
		},
		{
			MethodName: "HecklerNoopRange",
			Handler:    _Heckler_HecklerNoopRange_Handler,
		},
		{
			MethodName: "HecklerApply",
			Handler:    _Heckler_HecklerApply_Handler,
		},
		{
			MethodName: "HecklerLock",
			Handler:    _Heckler_HecklerLock_Handler,
		},
		{
			MethodName: "HecklerUnlock",
			Handler:    _Heckler_HecklerUnlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/hecklerpb/hecklerpb.proto",
}
